# 实验五 查找临近点

## 问题描述

如下图所示，在一个以(0,0), (L,0), (L,L), (0,L)为顶点的正方形内，给定二维空间中一组包含 N 个点的集合A，第 i 个点的坐标为𝑃𝑖(𝑎𝑖,𝑏𝑖)。
在上述区域内，给出另一个包含 M 个点的待查询点集 B，对 B 中的每个点 𝑄𝑗(𝑥𝑗,𝑦𝑗)，试报告点集 A 中与其距离不超过 𝑑𝑗 的点的个数 𝑛𝑗： 
𝑛𝑗 = | { 𝑃∈𝐴 | 𝑑(𝑃,𝑄𝑗)≤𝑑𝑗 } |, 其中 0≤𝑑𝑗≤𝐿/2

为了简化问题，我们做如下约定：

1） 采用切比雪夫距离定义。在二维平面上点 P1 和点 P2 的坐标分别为(x1, y1)及(x2, y2)，那么根据切比雪夫距离的定义有：d(P1,P2)=max ( |𝑥1−𝑥2|,|𝑦1−𝑦2| )

2） 点集 A 和点集 B 中所有点的坐标都是整数。

3） 点集 A中没有任何没有任何两点 x 坐标或 y 坐标相重 。即：∀𝑃𝑖∈A,𝑃𝑗∈A,i≠j,那么 𝑥𝑖≠𝑥𝑗且𝑦𝑖≠𝑦𝑗

4） 0<M,N≤ 1e5,0<𝐿≤1e6

## 输入描述

首行包含两个正整数 n>0, m>0. 其中 n = |A|, m = |B|. 也即 ，n表示平面上的点数，m表示待查询点的个数。 两个数以空格分隔。

随后 n 行中的第i行给出A中的第 i 个点： (𝑎𝑖,𝑏𝑖),𝑖=1,2,…,𝑛

这里，𝑎𝑖和𝑏𝑖均为整数，两个整数以空格分隔。

此后 m 行中的第 j 行给出点集 B 中第 j 个待查询点的坐标和相应的待查询距离：(𝑥𝑗, 𝑦𝑗 , 𝑑𝑗), 𝑗 = 1, 2, … , 𝑚

这里，𝑥𝑗, 𝑦𝑗 和 𝑑𝑗 均为整数，三个整数以空格分隔。

## 输出描述

共 m 行，第 j 行对应 B 中第 j 个点的查询结果。

## 输入样例

4 2

4 7

8 4

2 9

5 3

5 4 3

2 5 1

## 输出样例

3

0

## 提示

### 题设背景

本题的蛮力算法一目了然。但是，当 M 和 N 都很大（比如十万甚至百万以上的量级）时，蛮力算法 Ω(MN) 的时间复杂度将变得无法接受，有没有什么办法进行优化呢？

与前几次实验不同，本题的输入分两批给出。第一部分（点集 A）是固定的“背景”，而另一部分则是要进行的形式简单的查询操作，但此操作要大量反复地进行，而且
在某种意义上是随机的。比如，点集 A 是某区域地图上所有加油站的位置，作为服务提供商，我们希望在用户查询附近的加油站时能尽快给出答案，然而这些用户位于何处、还剩
多少油是不可能事先知晓的。所以我们能做的，就是对这大量的背景数据进行一番预处理，转化为某种特性的数据结构。

### 关键词
kd-tree， range tree
